

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>0101-0200 &mdash; go-leetcode v1.0.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="prev" title="0001-0100" href="0000-0100.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> go-leetcode
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="0000-0100.html">0001-0100</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">0101-0200</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">101. 对称二叉树</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">解答思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">104.二叉树的最大深度</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">解答思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ii">107.二叉树的层次遍历II</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10">108.将有序数组转换为二叉搜索树</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">110.平衡二叉树(缺少多种思路)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id16">111.二叉树的最小深度</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id17">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id18">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id19">112.路径总和</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id20">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id22">118.杨辉三角</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id23">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id24">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id25">119.杨辉三角II</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id26">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id27">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id28">121.买卖股票的最佳时机</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id29">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id30">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id31">122.买卖股票的最佳时机II</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id32">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id33">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id34">125.验证回文串</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id35">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id36">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id37">136.只出现一次的数字</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id38">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id39">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id40">141.环形链表</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id41">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id43">155.最小栈</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id44">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id45">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id46">160.相交链表</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id48">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id49">167.两数之和 II - 输入有序数组</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id50">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id51">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#excel">168.Excel表列名称</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id52">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id53">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id54">169.多数元素</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id55">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id56">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id57">171.Excel表列序号</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id58">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id59">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id60">172.阶乘后的零</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id61">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id62">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id63">189.旋转数组</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id64">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id65">解题思路</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id66">190.颠倒二进制位</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id67">题目</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id68">解题思路</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">go-leetcode</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>0101-0200</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/0101-0200.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>0101-0200<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>[TOC]</p>
<div class="section" id="id2">
<h2>101. 对称二叉树<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>题目<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
    1
   / \
  2   2
   \   \
   3    3

说明:
如果你可以运用递归和迭代两种方法解决这个问题，会很加分。
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>解答思路<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路 | 时间复杂度 | 空间复杂度 |
| ——– | —- | ———- | ———- |
| 01(最优) | 递归 | O(n)       | O(n)       |
| 02       | 迭代 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归</span>
<span class="kd">func</span> <span class="nx">isSymmetric</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">recur</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">recur</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">left</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Val</span> <span class="o">&amp;&amp;</span>
		<span class="nx">recur</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="nx">recur</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 迭代</span>
<span class="kd">func</span> <span class="nx">isSymmetric</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">leftQ</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">rightQ</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">leftQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">leftQ</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
	<span class="nx">rightQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rightQ</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rightQ</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">leftCur</span><span class="p">,</span> <span class="nx">rightCur</span> <span class="o">:=</span> <span class="nx">leftQ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">rightQ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">leftQ</span><span class="p">,</span> <span class="nx">rightQ</span> <span class="p">=</span> <span class="nx">leftQ</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">rightQ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

		<span class="k">if</span> <span class="nx">leftCur</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">rightCur</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">leftCur</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">rightCur</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">leftCur</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">rightCur</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
			<span class="nx">leftQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">leftQ</span><span class="p">,</span> <span class="nx">leftCur</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">leftCur</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="nx">rightQ</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rightQ</span><span class="p">,</span> <span class="nx">rightCur</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">rightCur</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leftQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rightQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2>104.二叉树的最大深度<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<div class="section" id="id6">
<h3>题目<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路 | 时间复杂度 | 空间复杂度 |
| ——– | —- | ———- | ———- |
| 01(最优) | 递归 | O(n)       | O(log(n))  |
| 02       | 迭代 | O(n)       | O(n)       |</p>
</div>
<div class="section" id="id7">
<h3>解答思路<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归</span>
<span class="kd">func</span> <span class="nx">maxDepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">left</span> <span class="o">:=</span> <span class="nx">maxDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nx">maxDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">max</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>


<span class="c1">// 迭代</span>
<span class="kd">func</span> <span class="nx">maxDepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">root</span><span class="p">)</span>
	<span class="nx">depth</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">{</span>
		<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span>

		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
			<span class="nx">node</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
				<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
				<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">depth</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">depth</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ii">
<h2>107.二叉树的层次遍历II<a class="headerlink" href="#ii" title="永久链接至标题">¶</a></h2>
<div class="section" id="id8">
<h3>题目<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7

返回其自底向上的层次遍历为：
[
  [15,7],
  [9,20],
  [3]
]
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>解题思路<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路 | 时间复杂度 | 空间复杂度 |
| ——– | —- | ———- | ———- |
| 01(最优) | 递归 | O(n)       | O(n)       |
| 02       | 迭代 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 迭代</span>
<span class="kd">func</span> <span class="nx">levelOrderBottom</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span>
		<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">pop</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">arr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">pop</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">pop</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">pop</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">pop</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">pop</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">out</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span>
		<span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="nx">l</span><span class="p">:]</span>
	<span class="p">}</span>

	<span class="nx">out2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">out2</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">out</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">out</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">out2</span>
<span class="p">}</span>

<span class="c1">// 递归</span>
<span class="kd">func</span> <span class="nx">levelOrderBottom</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">level</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">result</span>
	<span class="p">}</span>

	<span class="nx">orderBottom</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">result</span><span class="p">,</span> <span class="nx">level</span><span class="p">)</span>

	<span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
	<span class="k">for</span> <span class="nx">left</span> <span class="p">&lt;</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">left</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="p">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">right</span><span class="p">],</span> <span class="nx">result</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
		<span class="nx">left</span><span class="o">++</span>
		<span class="nx">right</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">orderBottom</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">result</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">level</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">result</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">level</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">level</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="nx">result</span><span class="p">)[</span><span class="nx">level</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">((</span><span class="o">*</span><span class="nx">result</span><span class="p">)[</span><span class="nx">level</span><span class="p">],</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">result</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">})</span>
	<span class="p">}</span>
	<span class="nx">orderBottom</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">orderBottom</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">level</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id10">
<h2>108.将有序数组转换为二叉搜索树<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<div class="section" id="id11">
<h3>题目<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>解题思路<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路 | 时间复杂度 | 空间复杂度 |
| ——– | —- | ———- | ———- |
| 01(最优) | 递归 | O(n)       | O(log(n))  |
| 02       | 迭代 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归</span>
<span class="kd">func</span> <span class="nx">sortedArrayToBST</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">mid</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span>
		<span class="nx">Val</span><span class="p">:</span>   <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">],</span>
		<span class="nx">Left</span><span class="p">:</span>  <span class="nx">sortedArrayToBST</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">mid</span><span class="p">]),</span>
		<span class="nx">Right</span><span class="p">:</span> <span class="nx">sortedArrayToBST</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">:]),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 迭代</span>
<span class="kd">type</span> <span class="nx">MyTreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">root</span>  <span class="o">*</span><span class="nx">TreeNode</span>
	<span class="nx">start</span> <span class="kt">int</span>
	<span class="nx">end</span>   <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">sortedArrayToBST</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">MyTreeNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">root</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
	<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">MyTreeNode</span><span class="p">{</span><span class="nx">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)})</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">myRoot</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="nx">start</span> <span class="o">:=</span> <span class="nx">myRoot</span><span class="p">.</span><span class="nx">start</span>
		<span class="nx">end</span> <span class="o">:=</span> <span class="nx">myRoot</span><span class="p">.</span><span class="nx">end</span>
		<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="nx">curRoot</span> <span class="o">:=</span> <span class="nx">myRoot</span><span class="p">.</span><span class="nx">root</span>
		<span class="nx">curRoot</span><span class="p">.</span><span class="nx">Val</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nx">mid</span> <span class="p">{</span>
			<span class="nx">curRoot</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
			<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">MyTreeNode</span><span class="p">{</span><span class="nx">curRoot</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">mid</span><span class="p">})</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">mid</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
			<span class="nx">curRoot</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
			<span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">MyTreeNode</span><span class="p">{</span><span class="nx">curRoot</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">})</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>110.平衡二叉树(缺少多种思路)<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="section" id="id14">
<h3>题目<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

    一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4

返回 false 。
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>解题思路<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<p>| No.  | 思路 | 时间复杂度 | 空间复杂度 |
| —- | —- | ———- | ———- |
| 01   | 递归 | O(n)       | O(log(n))  |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">isBalanced</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">isBalanced</span> <span class="o">:=</span> <span class="nx">recur</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">isBalanced</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nx">recur</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">leftDepth</span><span class="p">,</span> <span class="nx">leftIsBalanced</span> <span class="o">:=</span> <span class="nx">recur</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">leftIsBalanced</span> <span class="o">==</span> <span class="kc">false</span><span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">rightDepth</span><span class="p">,</span> <span class="nx">rightIsBalanced</span> <span class="o">:=</span> <span class="nx">recur</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">rightIsBalanced</span> <span class="o">==</span> <span class="kc">false</span><span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">leftDepth</span><span class="o">-</span><span class="nx">rightDepth</span> <span class="o">&amp;&amp;</span>
		<span class="nx">leftDepth</span><span class="o">-</span><span class="nx">rightDepth</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftDepth</span><span class="p">,</span> <span class="nx">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id16">
<h2>111.二叉树的最小深度<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<div class="section" id="id17">
<h3>题目<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明: 叶子节点是指没有子节点的节点。

示例:
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h3>解题思路<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01(最优) | 递归     | O(n)       | O(log(n))  |
| 02       | 广度优先 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归</span>
<span class="kd">func</span> <span class="nx">minDepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">min</span><span class="p">(</span><span class="nx">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">),</span> <span class="nx">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="c1">// 广度优先搜索</span>
<span class="kd">func</span> <span class="nx">minDepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">list</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">list</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span><span class="nx">root</span><span class="p">)</span>
	<span class="nx">depth</span> <span class="o">:=</span> <span class="mi">1</span>

	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">{</span>
		<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">list</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
			<span class="nx">node</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="nx">list</span> <span class="p">=</span> <span class="nx">list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
				<span class="k">return</span> <span class="nx">depth</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
				<span class="nx">list</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
				<span class="nx">list</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">depth</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">depth</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id19">
<h2>112.路径总和<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<div class="section" id="id20">
<h3>题目<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
示例: 
给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>解题思路<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路 | 时间复杂度 | 空间复杂度 |
| ——– | —- | ———- | ———- |
| 01(最优) | 递归 | O(n)       | O(log(n))  |
| 02       | 迭代 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 递归</span>
<span class="kd">func</span> <span class="nx">hasPathSum</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">-</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span>
	<span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">sum</span> <span class="o">==</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">hasPathSum</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="o">||</span> <span class="nx">hasPathSum</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 迭代</span>
<span class="kd">func</span> <span class="nx">hasPathSum</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">list1</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">New</span><span class="p">()</span>
	<span class="nx">list2</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">New</span><span class="p">()</span>

	<span class="nx">list1</span><span class="p">.</span><span class="nx">PushFront</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
	<span class="nx">list2</span><span class="p">.</span><span class="nx">PushFront</span><span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">length</span> <span class="o">:=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">Len</span><span class="p">()</span>

		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">node</span> <span class="o">:=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">Remove</span><span class="p">(</span><span class="nx">list1</span><span class="p">.</span><span class="nx">Back</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
			<span class="nx">currentSum</span> <span class="o">:=</span> <span class="nx">list2</span><span class="p">.</span><span class="nx">Remove</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="nx">Back</span><span class="p">()).(</span><span class="kt">int</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">currentSum</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">list1</span><span class="p">.</span><span class="nx">PushFront</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
				<span class="nx">list2</span><span class="p">.</span><span class="nx">PushFront</span><span class="p">(</span><span class="nx">currentSum</span> <span class="o">-</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">list1</span><span class="p">.</span><span class="nx">PushFront</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
				<span class="nx">list2</span><span class="p">.</span><span class="nx">PushFront</span><span class="p">(</span><span class="nx">currentSum</span> <span class="o">-</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id22">
<h2>118.杨辉三角<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h2>
<div class="section" id="id23">
<h3>题目<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h3>解题思路<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01       | 动态规划 | O(n^2)     | O(n^2)     |
| 02(最优) | 递推     | O(n^2)     | O(n^2)     |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 动态规划</span>
<span class="kd">func</span> <span class="nx">generate</span><span class="p">(</span><span class="nx">numRows</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">int</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numRows</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">row</span> <span class="p">[]</span><span class="kt">int</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">tmp</span> <span class="o">:=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">tmp</span> <span class="p">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="nx">row</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 递推</span>
<span class="kd">func</span> <span class="nx">generate</span><span class="p">(</span><span class="nx">numRows</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">numRows</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>

	<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">numRows</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numRows</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">genNext</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">genNext</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">p</span><span class="o">...</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id25">
<h2>119.杨辉三角II<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<div class="section" id="id26">
<h3>题目<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:
输入: 3
输出: [1,3,3,1]

进阶：
你可以优化你的算法到 O(k) 空间复杂度吗？
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h3>解题思路<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路       | 时间复杂度 | 空间复杂度 |
| ——– | ———- | ———- | ———- |
| 01       | 动态规划   | O(n^2)     | O(n^2)     |
| 02       | 递推       | O(n^2)     | O(n)       |
| 03(最优) | 二项式定理 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 动态规划</span>
<span class="kd">func</span> <span class="nx">getRow</span><span class="p">(</span><span class="nx">rowIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">int</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">rowIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">row</span> <span class="p">[]</span><span class="kt">int</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">tmp</span> <span class="o">:=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">tmp</span> <span class="p">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="nx">row</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span><span class="p">[</span><span class="nx">rowIndex</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 递推</span>
<span class="kd">func</span> <span class="nx">getRow</span><span class="p">(</span><span class="nx">rowIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nx">rowIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">rowIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">rowIndex</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="o">-</span><span class="mi">2</span> <span class="p">;</span> <span class="nx">j</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">{</span>
			<span class="nx">res</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+</span> <span class="nx">res</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="c1">// 二项式定理</span>
<span class="kd">func</span> <span class="nx">getRow</span><span class="p">(</span><span class="nx">rowIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">rowIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nx">rowIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>

	<span class="c1">// 公式</span>
	<span class="c1">// C(n,k）= n! /(k! * (n-k)!)</span>
	<span class="c1">// C(n,k) = (n-k+1)/k * C(n,k-1)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">rowIndex</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nx">rowIndex</span><span class="o">-</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">i</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id28">
<h2>121.买卖股票的最佳时机<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<div class="section" id="id29">
<h3>题目<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h3>解题思路<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                                                         | 时间复杂度 | 空间复杂度 |
| ——– | ———————————————————— | ———- | ———- |
| 01       | 暴力法                                                       | O(n^2)     | O(1)       |
| 02(最优) | 动态规划(从前到后) <br />最大利润=max{前一天最大利润, 今天的价格 - 之前最低价格} | O(n)       | O(1)       |
| 03       | 动态规划(从后到前)                                           | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 暴力法</span>
<span class="kd">func</span> <span class="nx">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">max</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">length</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">{</span>
			<span class="k">if</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">max</span><span class="p">{</span>
				<span class="nx">max</span> <span class="p">=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">max</span>
<span class="p">}</span>

<span class="c1">// 动态规划(从前到后)</span>
<span class="kd">func</span> <span class="nx">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">min</span> <span class="o">:=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">profit</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">min</span> <span class="p">{</span>
			<span class="nx">min</span> <span class="p">=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">profit</span> <span class="p">&lt;</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="nx">min</span> <span class="p">{</span>
			<span class="nx">profit</span> <span class="p">=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">min</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">profit</span>
<span class="p">}</span>


<span class="c1">// 动态规划(从后到前)</span>
<span class="kd">func</span> <span class="nx">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">max</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">profit</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">max</span> <span class="p">&lt;</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">max</span> <span class="p">=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">profit</span> <span class="p">&lt;</span> <span class="nx">max</span><span class="o">-</span><span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">profit</span> <span class="p">=</span> <span class="nx">max</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">profit</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id31">
<h2>122.买卖股票的最佳时机II<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h2>
<div class="section" id="id32">
<h3>题目<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h3>解题思路<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路       | 时间复杂度 | 空间复杂度 |
| ——– | ———- | ———- | ———- |
| 01(最优) | 贪心法     | O(n)       | O(1)       |
| 02       | 峰谷峰顶法 | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">max</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">max</span> <span class="p">=</span> <span class="nx">max</span> <span class="o">+</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">max</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">valley</span> <span class="o">:=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">peak</span> <span class="o">:=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">profit</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">valley</span> <span class="p">=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">peak</span> <span class="p">=</span> <span class="nx">prices</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">profit</span> <span class="p">=</span> <span class="nx">profit</span> <span class="o">+</span> <span class="nx">peak</span> <span class="o">-</span> <span class="nx">valley</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">profit</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id34">
<h2>125.验证回文串<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<div class="section" id="id35">
<h3>题目<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:
输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true

示例 2:
输入: &quot;race a car&quot;
输出: false
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h3>解题思路<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h3>
<p>| No.       | 思路     | 时间复杂度 | 空间复杂度 |
| ——— | ——– | ———- | ———- |
| 01( 最优) | 双指针法 | O(n)       | O(1)       |
| 02        | 双指针法 | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">isChar</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">isChar</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">isChar</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">func</span> <span class="nx">isPalindrome</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">ToLower</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&gt;=</span> <span class="sc">&#39;a&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">str</span> <span class="o">+=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">j</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id37">
<h2>136.只出现一次的数字<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<div class="section" id="id38">
<h3>题目<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
输入: [2,2,1]
输出: 1

示例 2:
输入: [4,1,2,1,2]
输出: 4
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h3>解题思路<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路     | 时间复杂度 | 空间复杂度 |
| ——– | ——– | ———- | ———- |
| 01(最优) | 异或     | O(n)       | O(1)       |
| 02       | 哈希     | O(n)       | O(n)       |
| 03       | 暴力法   | O(n^2)     | O(1)       |
| 04       | 排序遍历 | O(nlog(n)) | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 异或</span>
<span class="kd">func</span> <span class="nx">singleNumber</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nx">res</span> <span class="p">^</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="c1">// 哈希</span>
<span class="kd">func</span> <span class="nx">singleNumber</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span><span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span><span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">1</span><span class="p">{</span>
			<span class="k">return</span> <span class="nx">k</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// 暴力法</span>
<span class="kd">func</span> <span class="nx">singleNumber</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">flag</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">!=</span> <span class="nx">j</span> <span class="p">{</span>
				<span class="nx">flag</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">flag</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// 排序遍历</span>
<span class="kd">func</span> <span class="nx">singleNumber</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">i</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">){</span>
			<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]{</span>
			<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id40">
<h2>141.环形链表<a class="headerlink" href="#id40" title="永久链接至标题">¶</a></h2>
<div class="section" id="id41">
<h3>题目<a class="headerlink" href="#id41" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个链表，判断链表中是否有环。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 
如果 pos 是 -1，则在该链表中没有环。

示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
</pre></div>
</div>
</div>
<div class="section" id="id42">
<h3>解题思路<a class="headerlink" href="#id42" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路             | 时间复杂度 | 空间复杂度 |
| ——– | —————- | ———- | ———- |
| 01       | 哈希法           | O(n)       | O(n)       |
| 02(最优) | 双指针(快慢指针) | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">hasCycle</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">ListNode</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">head</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">head</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">head</span> <span class="p">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// 双指针(快慢指针)</span>
<span class="kd">func</span> <span class="nx">hasCycle</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">fast</span> <span class="o">:=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
	<span class="k">for</span> <span class="nx">fast</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">fast</span><span class="p">.</span><span class="nx">Next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">fast</span> <span class="o">==</span> <span class="nx">head</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="nx">fast</span> <span class="p">=</span> <span class="nx">fast</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Next</span>
		<span class="nx">head</span> <span class="p">=</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id43">
<h2>155.最小栈<a class="headerlink" href="#id43" title="永久链接至标题">¶</a></h2>
<div class="section" id="id44">
<h3>题目<a class="headerlink" href="#id44" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
    push(x) -- 将元素 x 推入栈中。
    pop() -- 删除栈顶的元素。
    top() -- 获取栈顶元素。
    getMin() -- 检索栈中的最小元素。
    
示例:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</pre></div>
</div>
</div>
<div class="section" id="id45">
<h3>解题思路<a class="headerlink" href="#id45" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                                               | 时间复杂度 | 空间复杂度 |
| ——– | ————————————————– | ———- | ———- |
| 01(最优) | 使用数组模拟栈，保存数据的时候同时保存当前的最小值 | O(n)       | O(n)       |
| 02       | 使用双栈                                           | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">item</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">min</span><span class="p">,</span> <span class="nx">x</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">MinStack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stack</span> <span class="p">[]</span><span class="nx">item</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">()</span> <span class="nx">MinStack</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">MinStack</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">min</span> <span class="o">:=</span> <span class="nx">x</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">this</span><span class="p">.</span><span class="nx">GetMin</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="nx">min</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">GetMin</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">item</span><span class="p">{</span>
		<span class="nx">min</span><span class="p">:</span> <span class="nx">min</span><span class="p">,</span>
		<span class="nx">x</span><span class="p">:</span>   <span class="nx">x</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">Top</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">GetMin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">min</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">type</span> <span class="nx">MinStack</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="p">[]</span><span class="kt">int</span>
	<span class="nx">min</span>  <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Constructor</span><span class="p">()</span> <span class="nx">MinStack</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">MinStack</span><span class="p">{[]</span><span class="kt">int</span><span class="p">{},</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">Push</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">x</span> <span class="o">&lt;=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">GetMin</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">this</span><span class="p">.</span><span class="nx">min</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">min</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">Pop</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">this</span><span class="p">.</span><span class="nx">data</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">this</span><span class="p">.</span><span class="nx">GetMin</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">this</span><span class="p">.</span><span class="nx">min</span> <span class="p">=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">min</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">Top</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MinStack</span><span class="p">)</span> <span class="nx">GetMin</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">this</span><span class="p">.</span><span class="nx">min</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">this</span><span class="p">.</span><span class="nx">min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id46">
<h2>160.相交链表<a class="headerlink" href="#id46" title="永久链接至标题">¶</a></h2>
<div class="section" id="id47">
<h3>题目<a class="headerlink" href="#id47" title="永久链接至标题">¶</a></h3>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span>编写一个程序，找到两个单链表相交的起始节点。
如下面的两个链表：
在节点 c1 开始相交。

示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：
    如果两个链表没有交点，返回 null.
    在返回结果后，两个链表仍须保持原有的结构。
    可假定整个链表结构中没有循环。
    程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
</pre></div>
</div>
</div>
<div class="section" id="id48">
<h3>解题思路<a class="headerlink" href="#id48" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                       | 时间复杂度 | 空间复杂度 |
| ——– | ————————– | ———- | ———- |
| 01       | 计算长度后，对齐长度再比较 | O(n)       | O(1)       |
| 02(最优) | 交换后相连，再比较         | O(n)       | O(1)       |
| 03       | 暴力法                     | O(n^2)     | O(1)       |
| 04       | 哈希法                     | O(n)       | O(n)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">getIntersectionNode</span><span class="p">(</span><span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="nx">ALength</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">A</span> <span class="o">:=</span> <span class="nx">headA</span>
	<span class="k">for</span> <span class="nx">A</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ALength</span><span class="o">++</span>
		<span class="nx">A</span> <span class="p">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="nx">BLength</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">B</span> <span class="o">:=</span> <span class="nx">headB</span>
	<span class="k">for</span> <span class="nx">B</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">BLength</span><span class="o">++</span>
		<span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>

	<span class="nx">pA</span> <span class="o">:=</span> <span class="nx">headA</span>
	<span class="nx">pB</span> <span class="o">:=</span> <span class="nx">headB</span>
	<span class="k">if</span> <span class="nx">ALength</span> <span class="p">&gt;</span> <span class="nx">BLength</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">ALength</span> <span class="o">-</span> <span class="nx">BLength</span>
		<span class="k">for</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">pA</span> <span class="p">=</span> <span class="nx">pA</span><span class="p">.</span><span class="nx">Next</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="o">:=</span> <span class="nx">BLength</span> <span class="o">-</span> <span class="nx">ALength</span>
		<span class="k">for</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">pB</span> <span class="p">=</span> <span class="nx">pB</span><span class="p">.</span><span class="nx">Next</span>
			<span class="nx">n</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">pA</span> <span class="o">!=</span> <span class="nx">pB</span> <span class="p">{</span>
		<span class="nx">pA</span> <span class="p">=</span> <span class="nx">pA</span><span class="p">.</span><span class="nx">Next</span>
		<span class="nx">pB</span> <span class="p">=</span> <span class="nx">pB</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">pA</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">func</span> <span class="nx">getIntersectionNode</span><span class="p">(</span><span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="nx">A</span><span class="p">,</span> <span class="nx">B</span> <span class="o">:=</span> <span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span>
	<span class="k">for</span> <span class="nx">A</span> <span class="o">!=</span> <span class="nx">B</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">A</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">A</span> <span class="p">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">A</span> <span class="p">=</span> <span class="nx">headB</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">B</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">B</span> <span class="p">=</span> <span class="nx">headA</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">A</span>
<span class="p">}</span>

<span class="c1">// 暴力法 </span>
<span class="kd">func</span> <span class="nx">getIntersectionNode</span><span class="p">(</span><span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="nx">A</span><span class="p">,</span> <span class="nx">B</span> <span class="o">:=</span> <span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span>
	<span class="k">for</span> <span class="nx">A</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">B</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">A</span> <span class="o">==</span> <span class="nx">B</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">A</span>
			<span class="p">}</span>
			<span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span><span class="p">.</span><span class="nx">Next</span>
		<span class="p">}</span>
		<span class="nx">A</span> <span class="p">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">Next</span>
		<span class="nx">B</span> <span class="p">=</span> <span class="nx">headB</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 哈希表法</span>
<span class="kd">func</span> <span class="nx">getIntersectionNode</span><span class="p">(</span><span class="nx">headA</span><span class="p">,</span> <span class="nx">headB</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">ListNode</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">headA</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">headA</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">headA</span> <span class="p">=</span> <span class="nx">headA</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">headB</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">headB</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">headB</span>
		<span class="p">}</span>
		<span class="nx">headB</span> <span class="p">=</span> <span class="nx">headB</span><span class="p">.</span><span class="nx">Next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id49">
<h2>167.两数之和 II - 输入有序数组<a class="headerlink" href="#id49" title="永久链接至标题">¶</a></h2>
<div class="section" id="id50">
<h3>题目<a class="headerlink" href="#id50" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:
    返回的下标值（index1 和 index2）不是从零开始的。
    你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

示例:
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h3>解题思路<a class="headerlink" href="#id51" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                | 时间复杂度 | 空间复杂度 |
| ——– | ——————- | ———- | ———- |
| 01       | 暴力法: 2层循环遍历 | O(n^2)     | O(1)       |
| 02       | 两遍哈希遍历        | O(n)       | O(n)       |
| 03       | 一遍哈希遍历        | O(n)       | O(n)       |
| 04(最优) | 一遍哈希遍历        | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 暴力法: 2层循环遍历</span>
<span class="kd">func</span> <span class="nx">twoSum</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
				<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 两遍哈希遍历</span>
<span class="kd">func</span> <span class="nx">twoSum</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span> <span class="p">{</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">=</span> <span class="nx">k</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">target</span> <span class="o">-</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">num</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">b</span><span class="p">];</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">num</span> <span class="o">!=</span> <span class="nx">i</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="nx">b</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 一遍哈希遍历</span>
<span class="kd">func</span> <span class="nx">twoSum</span><span class="p">(</span><span class="nx">numbers</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">numbers</span><span class="p">))</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">numbers</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">target</span><span class="o">-</span><span class="nx">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">m</span><span class="p">[</span><span class="nx">target</span><span class="o">-</span><span class="nx">n</span><span class="p">],</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
		<span class="p">}</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 双指针法</span>
<span class="kd">func</span> <span class="nx">twoSum</span><span class="p">(</span><span class="nx">numbers</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">first</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span><span class="o">+</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">first</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">last</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">return</span> <span class="nx">result</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">first</span><span class="p">]</span><span class="o">+</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">last</span><span class="o">--</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">first</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="excel">
<h2>168.Excel表列名称<a class="headerlink" href="#excel" title="永久链接至标题">¶</a></h2>
<div class="section" id="id52">
<h3>题目<a class="headerlink" href="#id52" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个正整数，返回它在 Excel 表中相对应的列名称。
例如，

    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB 
    ...
示例 1:
输入: 1
输出: &quot;A&quot;

示例 2:
输入: 28
输出: &quot;AB&quot;

示例 3:
输入: 701
输出: &quot;ZY&quot;
</pre></div>
</div>
</div>
<div class="section" id="id53">
<h3>解题思路<a class="headerlink" href="#id53" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路         | 时间复杂度 | 空间复杂度 |
| ——– | ———— | ———- | ———- |
| 01(最优) | 求余模拟进制 | O(log(n))  | O(1)       |
| 02       | 递归计算     | O(log(n))  | O(log(n))  |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 求余模拟进制</span>
<span class="kd">func</span> <span class="nx">convertToTitle</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>

	<span class="k">for</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">n</span><span class="o">--</span>
		<span class="nx">str</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nb">byte</span><span class="p">(</span><span class="nx">n</span><span class="o">%</span><span class="mi">26</span><span class="p">)</span><span class="o">+</span><span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="nx">str</span>
		<span class="nx">n</span> <span class="o">/=</span> <span class="mi">26</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">str</span>
<span class="p">}</span>

<span class="c1">// 递归计算</span>
<span class="kd">func</span> <span class="nx">convertToTitle</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">26</span><span class="p">{</span>
		<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">y</span> <span class="o">:=</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">26</span>
	<span class="k">if</span> <span class="nx">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">{</span>
		<span class="c1">// 26的倍数 如52%26=0 =&gt; AZ</span>
		<span class="k">return</span> <span class="nx">convertToTitle</span><span class="p">((</span><span class="nx">n</span><span class="o">-</span><span class="nx">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">26</span><span class="p">)</span><span class="o">+</span><span class="nx">convertToTitle</span><span class="p">(</span><span class="mi">26</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">convertToTitle</span><span class="p">((</span><span class="nx">n</span><span class="o">-</span><span class="nx">y</span><span class="p">)</span><span class="o">/</span><span class="mi">26</span><span class="p">)</span><span class="o">+</span><span class="nx">convertToTitle</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id54">
<h2>169.多数元素<a class="headerlink" href="#id54" title="永久链接至标题">¶</a></h2>
<div class="section" id="id55">
<h3>题目<a class="headerlink" href="#id55" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1:
输入: [3,2,3]
输出: 3

示例 2:
输入: [2,2,1,1,1,2,2]
输出: 2
</pre></div>
</div>
</div>
<div class="section" id="id56">
<h3>解题思路<a class="headerlink" href="#id56" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路                | 时间复杂度 | 空间复杂度 |
| ——– | ——————- | ———- | ———- |
| 01       | 排序取半            | O(log(n))  | O(1)       |
| 02       | 哈希法              | O(n)       | O(n)       |
| 03(最优) | Boyer-Moore投票算法 | O(n)       | O(1)       |
| 04       | 位运算              | O(n)       | O(1)       |
| 05       | 分治法              | O(nlog(n)) | O(log(n))  |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 排序取半</span>
<span class="kd">func</span> <span class="nx">majorityElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nx">Ints</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 哈希法</span>
<span class="kd">func</span> <span class="nx">majorityElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nums</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span><span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">];</span><span class="nx">ok</span><span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span><span class="o">++</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
			<span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]=</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">m</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">){</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">v</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// Boyer-Moore投票算法</span>
<span class="kd">func</span> <span class="nx">majorityElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span><span class="p">,</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">result</span> <span class="o">==</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">// 位运算</span>
<span class="kd">func</span> <span class="nx">majorityElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// 64位有坑</span>
	<span class="nx">mask</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">mask</span><span class="o">&amp;</span><span class="nb">int32</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="o">==</span> <span class="nx">mask</span> <span class="p">{</span>
				<span class="nx">count</span><span class="o">++</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
			<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="p">|</span> <span class="nx">mask</span>
		<span class="p">}</span>
		<span class="nx">mask</span> <span class="p">=</span> <span class="nx">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 分治法</span>
<span class="kd">func</span> <span class="nx">majorityElement</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">majority</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">count</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">start</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">countNum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
			<span class="nx">countNum</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">countNum</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">majority</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">start</span> <span class="o">==</span> <span class="nx">end</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">start</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">mid</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

	<span class="nx">left</span> <span class="o">:=</span> <span class="nx">majority</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">mid</span><span class="p">)</span>
	<span class="nx">right</span> <span class="o">:=</span> <span class="nx">majority</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">left</span>
	<span class="p">}</span>

	<span class="nx">leftCount</span> <span class="o">:=</span> <span class="nx">count</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
	<span class="nx">rightCount</span> <span class="o">:=</span> <span class="nx">count</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">leftCount</span> <span class="p">&gt;</span> <span class="nx">rightCount</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">left</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">right</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id57">
<h2>171.Excel表列序号<a class="headerlink" href="#id57" title="永久链接至标题">¶</a></h2>
<div class="section" id="id58">
<h3>题目<a class="headerlink" href="#id58" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个Excel表格中的列名称，返回其相应的列序号。
例如，
    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 
    ...

示例 1:
输入: &quot;A&quot;
输出: 1

示例 2:
输入: &quot;AB&quot;
输出: 28

示例 3:
输入: &quot;ZY&quot;
输出: 701
</pre></div>
</div>
</div>
<div class="section" id="id59">
<h3>解题思路<a class="headerlink" href="#id59" title="永久链接至标题">¶</a></h3>
<p>| No.  | 思路       | 时间复杂度 | 空间复杂度 |
| —- | ———- | ———- | ———- |
| 01   | 26进制计算 | O(log(n))  | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">titleToNumber</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span><span class="o">*</span><span class="mi">26</span> <span class="o">+</span> <span class="nx">temp</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id60">
<h2>172.阶乘后的零<a class="headerlink" href="#id60" title="永久链接至标题">¶</a></h2>
<div class="section" id="id61">
<h3>题目<a class="headerlink" href="#id61" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。

示例 2:
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.

说明: 你算法的时间复杂度应为 O(log n) 。
</pre></div>
</div>
</div>
<div class="section" id="id62">
<h3>解题思路<a class="headerlink" href="#id62" title="永久链接至标题">¶</a></h3>
<p>| No.  | 思路         | 时间复杂度 | 空间复杂度 |
| —- | ———— | ———- | ———- |
| 01   | 数学，找规律 | O(log(n))  | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">trailingZeroes</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="mi">5</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="nx">result</span> <span class="o">+</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id63">
<h2>189.旋转数组<a class="headerlink" href="#id63" title="永久链接至标题">¶</a></h2>
<div class="section" id="id64">
<h3>题目<a class="headerlink" href="#id64" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

示例 2:
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

说明:
    尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
    要求使用空间复杂度为 O(1) 的 原地 算法。
</pre></div>
</div>
</div>
<div class="section" id="id65">
<h3>解题思路<a class="headerlink" href="#id65" title="永久链接至标题">¶</a></h3>
<p>| No.      | 思路           | 时间复杂度 | 空间复杂度 |
| ——– | ————– | ———- | ———- |
| 01       | 暴力法         | O(n^2)     | O(1)       |
| 02       | 三次反转法     | O(n)       | O(1)       |
| 03       | 使用额外的数组 | O(n)       | O(n)       |
| 04(最优) | 环形替换       | O(n)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 暴力法</span>
<span class="kd">func</span> <span class="nx">rotate</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="nx">k</span> <span class="o">%</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">last</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">last</span> <span class="p">=</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 三次反转法</span>
<span class="kd">func</span> <span class="nx">rotate</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="nx">k</span> <span class="o">%</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">reverse</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">reverse</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">reverse</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">j</span><span class="o">--</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 使用额外的数组</span>
<span class="kd">func</span> <span class="nx">rotate</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="nx">k</span> <span class="o">%</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">arr</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">arr</span><span class="p">[(</span><span class="nx">i</span><span class="o">+</span><span class="nx">k</span><span class="p">)</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 环形替换</span>
<span class="kd">func</span> <span class="nx">rotate</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">k</span> <span class="p">=</span> <span class="nx">k</span> <span class="o">%</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">count</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="o">:=</span> <span class="nx">i</span>
		<span class="nx">prev</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">next</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">current</span> <span class="o">+</span> <span class="nx">k</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">next</span><span class="p">],</span> <span class="nx">prev</span> <span class="p">=</span> <span class="nx">prev</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">next</span><span class="p">]</span>
			<span class="nx">current</span> <span class="p">=</span> <span class="nx">next</span>
			<span class="c1">// fmt.Println(nums, prev)</span>
			<span class="nx">count</span><span class="o">++</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">current</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id66">
<h2>190.颠倒二进制位<a class="headerlink" href="#id66" title="永久链接至标题">¶</a></h2>
<div class="section" id="id67">
<h3>题目<a class="headerlink" href="#id67" title="永久链接至标题">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>颠倒给定的 32 位无符号整数的二进制位。

示例 1：
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

示例 2：
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。

提示：
    请注意，在某些语言（如 Java）中，没有无符号整数类型。
    在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，
    因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
    在 Java 中，编译器使用二进制补码记法来表示有符号整数。
    因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
进阶:
如果多次调用这个函数，你将如何优化你的算法？
</pre></div>
</div>
</div>
<div class="section" id="id68">
<h3>解题思路<a class="headerlink" href="#id68" title="永久链接至标题">¶</a></h3>
<p>| No.  | 思路       | 时间复杂度 | 空间复杂度 |
| —- | ———- | ———- | ———- |
| 01   | 位操作     | O(1)       | O(1)       |
| 02   | 转字符串   | O(n)       | O(1)       |
| 03   | 二进制交换 | O(1)       | O(1)       |</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">reverseBits</span><span class="p">(</span><span class="nx">num</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">last</span> <span class="o">:=</span> <span class="nx">num</span> <span class="o">&amp;</span> <span class="mi">1</span>               <span class="c1">// 取最后一位</span>
		<span class="nx">result</span> <span class="p">=</span> <span class="p">(</span><span class="nx">result</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">last</span> <span class="c1">// 前移</span>
		<span class="nx">num</span> <span class="p">=</span> <span class="nx">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="kd">func</span> <span class="nx">reverseBits</span><span class="p">(</span><span class="nx">num</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="nx">str</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">FormatUint</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">num</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">rev</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="nx">rev</span> <span class="p">=</span> <span class="nx">rev</span> <span class="o">+</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rev</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">32</span> <span class="p">{</span>
		<span class="nx">rev</span> <span class="p">=</span> <span class="nx">rev</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Repeat</span><span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nx">rev</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">ParseUint</span><span class="p">(</span><span class="nx">rev</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 二进制交换</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&quot;github.com/imroc/biu&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">reverseBits</span><span class="p">(</span><span class="nx">num</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">biu</span><span class="p">.</span><span class="nx">Uint32ToBinaryString</span><span class="p">(</span><span class="nx">num</span><span class="p">))</span>
	<span class="nx">num</span> <span class="p">=</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">|</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
	<span class="nx">num</span> <span class="p">=</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0xff00ff00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">|</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0x00ff00ff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">num</span> <span class="p">=</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0xf0f0f0f0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">|</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0x0f0f0f0f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>
	<span class="nx">num</span> <span class="p">=</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0xcccccccc</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">|</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0x33333333</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">num</span> <span class="p">=</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0xaaaaaaaa</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">|</span> <span class="p">((</span><span class="nx">num</span> <span class="o">&amp;</span> <span class="mh">0x55555555</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">num</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="0000-0100.html" class="btn btn-neutral float-left" title="0001-0100" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, willshang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>